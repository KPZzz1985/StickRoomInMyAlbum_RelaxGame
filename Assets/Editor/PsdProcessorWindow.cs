using UnityEngine;
using UnityEditor;
using System.Linq;
using System.IO;
using System.Collections.Generic;

public class PsdProcessorWindow : EditorWindow
{
    [MenuItem("Tools/PSD Processor")]
    public static void ShowWindow()
    {
        GetWindow<PsdProcessorWindow>("PSD Processor");
    }

    private string _psdFolder = "Assets/PSDs";

    private void OnGUI()
    {
        GUILayout.Label("Настройки PSD Processor", EditorStyles.boldLabel);
        _psdFolder = EditorGUILayout.TextField("Папка PSD:", _psdFolder);

        if (GUILayout.Button("Process All PSD"))
        {
            ProcessAllPsdFiles(_psdFolder);
            AssetDatabase.SaveAssets();
        }
    }

    private static void ProcessAllPsdFiles(string folder)
    {
        string[] guids = AssetDatabase.FindAssets("t:Texture2D", new[] { folder });
        foreach (string guid in guids)
        {
            string path = AssetDatabase.GUIDToAssetPath(guid);
            if (!path.EndsWith(".psd")) continue;

            // Ensure PSD imported as multiple sprites
            var importer = AssetImporter.GetAtPath(path) as TextureImporter;
            if (importer != null)
            {
                importer.textureType = TextureImporterType.Sprite;
                importer.spriteImportMode = SpriteImportMode.Multiple;
                // Center pivot for all slices
                var ti = importer;
                var metas = ti.spritesheet;
                for (int i = 0; i < metas.Length; i++)
                {
                    var m = metas[i];
                    m.alignment = (int)SpriteAlignment.Center;
                    m.pivot = new Vector2(0.5f, 0.5f);
                    metas[i] = m;
                }
                ti.spritesheet = metas;
                // Apply and reimport with updated pivot settings
                importer.SaveAndReimport();
                AssetDatabase.Refresh();
            }

            // Загружаем все ассеты на пути, чтобы получить спрайты из PSD
            var assets = AssetDatabase.LoadAllAssetsAtPath(path);
            Sprite[] sprites = assets.OfType<Sprite>().ToArray();
            // Находим первый GameObject subasset (prefab), сгенерированный PSD Importer
            // Find the root prefab generated by PSD Importer matching PSD name
            string rootName = Path.GetFileNameWithoutExtension(path);
            var prefabAsset = assets.OfType<GameObject>().FirstOrDefault(go => go.name == rootName);
            if (prefabAsset == null)
                prefabAsset = assets.OfType<GameObject>().FirstOrDefault();
            // Передаем prefabAsset в метод для сохранения в метаданных
            ProcessSpritesFromPsd(path, sprites, prefabAsset);
        }
    }

    // Рекурсивный поиск первого SpriteRenderer в любой глубине иерархии
    private static SpriteRenderer FindSpriteRendererInChildren(Transform parent)
    {
        // СНАЧАЛА проверяем сам объект
        var sr = parent.GetComponent<SpriteRenderer>();
        if (sr != null && sr.sprite != null)
        {
            Debug.Log($"Found SpriteRenderer in {parent.name}: {sr.sprite.name}");
            return sr;
        }
            
        // Потом рекурсивно проверяем всех детей
        foreach (Transform child in parent)
        {
            var childSr = FindSpriteRendererInChildren(child);
            if (childSr != null)
                return childSr;
        }
        
        return null;
    }

    // Поиск Sprite ассета по имени из массива всех спрайтов PSD
    private static Sprite FindSpriteAssetByName(string spriteName, Sprite[] allSprites)
    {
        foreach (var sprite in allSprites)
        {
            if (sprite.name == spriteName)
            {
                Debug.Log($"Found sprite asset: {spriteName}");
                return sprite;
            }
        }
        Debug.LogWarning($"Sprite asset not found: {spriteName}");
        return null;
    }

    private static void ProcessSpritesFromPsd(string psdPath, Sprite[] sprites, GameObject prefabAsset)
    {
        Debug.Log($"Processing PSD: {psdPath}");
        var assets = AssetDatabase.LoadAllAssetsAtPath(psdPath);

        // Setup metadata asset
        var metaFolder = Path.GetDirectoryName(psdPath) + "/Metadata";
        if (!AssetDatabase.IsValidFolder(metaFolder))
            AssetDatabase.CreateFolder(Path.GetDirectoryName(psdPath), "Metadata");
        var metaPath = metaFolder + "/" + Path.GetFileNameWithoutExtension(psdPath) + "_Metadata.asset";
        var metadata = AssetDatabase.LoadAssetAtPath<PsdMetadata>(metaPath);
        if (metadata == null)
        {
            metadata = ScriptableObject.CreateInstance<PsdMetadata>();
            metadata.psdName = Path.GetFileNameWithoutExtension(psdPath);
            metadata.psdPrefab = prefabAsset;
            AssetDatabase.CreateAsset(metadata, metaPath);
        }
        else
        {
            metadata.psdPrefab = prefabAsset;
        }

        // Instantiate prefab temporarily for parsing
        var root = Instantiate(prefabAsset);
        root.name = prefabAsset.name + "_Temp";

        // Clear old lists
        metadata.backgroundLayers.Clear();
        metadata.zoneLayers.Clear();
        metadata.overlayLayers.Clear();
        metadata.stickerDatas.Clear();

        // Parse background layers from BG_Room group
        var bgGroup = root.transform.Find("BG_Room");
        if (bgGroup != null)
        {
            foreach (Transform bgChild in bgGroup)
            {
                var sr = bgChild.GetComponent<SpriteRenderer>();
                if (sr != null && sr.sprite != null)
                {
                    var spriteAsset = FindSpriteAssetByName(sr.sprite.name, sprites);
                    metadata.backgroundLayers.Add(new PsdLayerData {
                        id = bgChild.name,
                        layerPrefab = bgChild.gameObject,
                        sprite = spriteAsset,
                        position = bgChild.localPosition,
                        sortingOrder = sr.sortingOrder
                    });
                }
            }
        }

        // Parse global zone layers from Previous_Sticker_Shadow_Placer
        var prevGroup = root.transform.Find("Previous_Sticker_Shadow_Placer");
        if (prevGroup != null)
        {
            foreach (Transform zoneGrp in prevGroup)
            {
                var sr = zoneGrp.GetComponentInChildren<SpriteRenderer>();
                if (sr != null && sr.sprite != null)
                {
                    var spriteAsset = FindSpriteAssetByName(sr.sprite.name, sprites);
                    metadata.zoneLayers.Add(new PsdLayerData {
                        id = zoneGrp.name.Replace("PLACER_STK_", ""),
                        layerPrefab = zoneGrp.gameObject,
                        sprite = spriteAsset,
                        position = sr.transform.localPosition,
                        sortingOrder = sr.sortingOrder
                    });
                }
            }
        }

        // Parse per-sticker data from Stickers_Stash
        var stashGroup = root.transform.Find("Stickers_Stash");
        if (stashGroup != null)
        {
            foreach (Transform stkGrp in stashGroup)
            {
                if (!stkGrp.name.StartsWith("STK_")) continue;
                var srBase = FindSpriteRendererInChildren(stkGrp.Find("Base"));
                if (srBase == null) continue;
                var spriteAsset = FindSpriteAssetByName(srBase.sprite.name, sprites);
                var sd = new PsdStickerData {
                    id = stkGrp.name,
                    layerPrefab = stkGrp.gameObject,
                    baseSprite = spriteAsset,
                    position = srBase.transform.localPosition,
                    sortingOrder = srBase.sortingOrder
                };
                // nested zones
                var placeZone = stkGrp.Find("Place_Zone");
                if (placeZone != null)
                {
                    foreach (Transform zone in placeZone)
                    {
                        var srZone = zone.GetComponentInChildren<SpriteRenderer>();
                        if (srZone != null && srZone.sprite != null)
                        {
                            var assetZ = zone.gameObject;
                            var spriteZ = FindSpriteAssetByName(srZone.sprite.name, sprites);
                            sd.nestedZoneLayers.Add(new PsdLayerData {
                                id = zone.name.Replace("PLACER_STK_", ""),
                                layerPrefab = assetZ,
                                sprite = spriteZ,
                                position = srZone.transform.localPosition,
                                sortingOrder = srZone.sortingOrder
                            });
                        }
                    }
                }
                // nested overlays
                var overlayZone = stkGrp.Find("Overlay");
                if (overlayZone != null)
                {
                    foreach (Transform ov in overlayZone)
                    {
                        var srO = ov.GetComponentInChildren<SpriteRenderer>();
                        if (srO != null && srO.sprite != null)
                        {
                            var assetO = ov.gameObject;
                            var spriteO = FindSpriteAssetByName(srO.sprite.name, sprites);
                            sd.nestedOverlayLayers.Add(new PsdLayerData {
                                id = ov.name,
                                layerPrefab = assetO,
                                sprite = spriteO,
                                position = srO.transform.localPosition,
                                sortingOrder = srO.sortingOrder
                            });
                        }
                    }
                }
                metadata.stickerDatas.Add(sd);
            }
        }

        // Clean up
        DestroyImmediate(root);
        EditorUtility.SetDirty(metadata);
        AssetDatabase.SaveAssets();
        Debug.Log($"Parsed PSD: BG:{metadata.backgroundLayers.Count}, Stickers:{metadata.stickerDatas.Count}, Zones:{metadata.zoneLayers.Count}, Overlay:{metadata.overlayLayers.Count}");
    }
    
    private static void LogChildrenRecursive(Transform parent, int depth)
    {
        string indent = new string(' ', depth * 4);
        for (int i = 0; i < parent.childCount; i++)
        {
            var child = parent.GetChild(i);
            var sr = child.GetComponent<SpriteRenderer>();
            Debug.Log($"{indent}Child {i}: {child.name} (childCount: {child.childCount}, has SpriteRenderer: {sr != null}, sprite: {sr?.sprite?.name})");
            
            if (child.childCount > 0)
            {
                LogChildrenRecursive(child, depth + 1);
            }
        }
    }
}